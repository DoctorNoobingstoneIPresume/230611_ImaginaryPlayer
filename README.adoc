= [2023-06-11] ImaginaryPlayer
:docinfo: shared
:date:    2023-06-11
:toc:     macro

== README

Example of Worker Threads and Message Passing (as opposed to lower-level synchronization).



== Contact/support:

adder_2003@yahoo.com -- Thank you so !! (-:



== Building the Project

Bash script for the impatient:

```
set -o pipefail; readarray -t as < <(ls *.cpp | grep -Piv "_UT"); printf "%s\n" "${as[@]}"; xtimeq g++ -pthread -std="gnu++17" -g "${as[@]}" -o "Main" 2>&1 | tee "_go"
```

Alternatively, we can use the custom build system (with some hardcoding, currently):

```
./Go 2>&1 | tee "_go"
```

This is going to:

* compile each `.cpp` file;
* gather together most object files into an archive (a static library);
* link the shared library and the `Main.o` object file into the `Main` executable;
* link the shared library and each `*_UT.o` object file into a `*_UT` executable (a unittest);
* run each unittest.

All files generated by compilation, archiving, and linking are placed in the `"_Build/"` sub-folder.



== Running the Project

When we run `"_Build/Main"`, the Player is going to be initialized with two imaginary songs,
one of length 3 seconds and the other of length 6 seconds, and is going to be in the "Playing" state.

The user can enter commands after the `"[Main] >"` prompt (on the next line).

Because output from the Player (prefixed by `"[Play]"`) is mixed with output from the Main thread (prefixed by `"[Main]"`),
the prompt might get lost in the "noise". However, the user should not be discouraged by this and just type his/her commands.
The `"help"` command is going to show a list of available commands. Commands are case-insensitive.

=== User commands

[%autowidth]
[cols="1,1"]
|===
|Command (regex)|Effect

|`Help`
|Displays help for the user.

|`Exit`
|Gracefully stops the process.

|`Show\|ShowPlayer`
|Displays debugging information about the Player.

|`Verb <level>`
|Sets the verbosity level for the Player (`0` or `1`). Initial value: `0`.

|`AddSong \(<song-description>\)`
|Adds the specified song to the queue.

|`Play\|Pause`
|Toggles the "playing" state.

|`Sleep <number-of-milliseconds>`
| Puts the main thread to sleep => commands are not going to be processed for the specified duration. (This command is useful for functional tests.)

|`Prev|Next`
| Jumps to the previous song or to the next song (in history).
|===

Example of `<song-description>`:

```
(artist "Madonna", song "Frozen", codec "MP3", length 329000)
```


== Functional test

By running `"./Test.pl"`, a functional test is going to be executed.
It feeds the input in the script to the `"_Build/Main"` program, captures the output, and analyzes it.



== Coding style and naming conventions

Classes (and class templates) and functions (and function templates) are named `LikeThis`.

Variables are named `likeThis`. Member variables are named `_likeThis`.

Where possible, there is a whitespace between text and opening parenthesis (just like in normal text (for example, in this very line you are reading now)).



== Naming of variables

Hungarian Notation is used quite often, as learnt a long time from the beloved "Programming Windows 95" book by Charles Petzold.
In Hungarian Notation, each name is prefixed with a few lowercase characters which identify the type of the variable.

Examples:

* `contSongs`: A container of `Song` objects.
* `sInput`: A string containing the input (to the current piece of code, e.g. function etc.).

Advantages:

* we can see the type of the variable without looking up its declaration;
* it becomes easy to produce names (based simply on the type).

Disadvantages:

* it takes a little getting used to;
* with generic programming (templates), it may sometimes be difficult to know the type of a variable.

Actually, a simplified version of the Hungarian Notation is used, which does not stress too much the accuracy of the naming prefix.
For examples, integrals are often prefixed with just `i` or `n`, irrespective of the exact type of the integral (i.e. `int` or `unsigned int` or `int64_t` or `uint64_t`).

Reference variables are named just like the object variables, without an additional prefix for "reference".
Pointer variables are names similarly to the pointees, with the addition of a `p` prefix, e.g. `pContSongs` or `pcontSongs` is a "pointer to container of `Song` objects".

Often-used prefixes:

[%autowidth]
[cols="1,1"]
|===
|Prefix|Meaning

|`b`
|`bool` or (rarely if ever) byte (e.g. `unsigned char` etc.).

|`i\|n`
|Integral. `i` often denotes an index, `n` often denotes a count (a number of elements etc.).

|`c`
| Character (`char`, `wchar_t` etc.).

|`s`
|String (`std::string`, `std::wstring` etc.).

|`psz`
|Pointer to NUL-terminated array of characters ("pointer to zero-terminated string").

|`sv\|s`
|String view (`std::string_view` etc.). Often, when the distinction between `std::string` and `std::string_view` is merely related to optimization, we use `s` for `string_view`'s too.

|`cont`
|Container.

|`iter`
|Iterator.

|`opt`
|`std::optional <...>`

|`p`
|Pointer.

|`sp`
|`std::shared_ptr <...>`. Note that when the distinction between `std::shared_ptr <...>`'s and raw pointer is not important, we might use `p` for `std::shared_ptr <...>`'s too.

|`rv`
|Return value.

|`value`
|Variable holding the argument of a setter function.

|===



== `std` vs `boost`

With a modern version of G++, Boost libraries are not needed.

But on the particular home computer used to develop the project, I have g++-5.4.
It has some support for C++17, but without `std::optional <...>` and without `std::basic_string_view <...>` (and without structured bindings too).
Therefore, during building, we allow a choice between the Boost versions and the Standard Library versions for these libraries.

Please see `"string_view.hpp"` and `"optional.hpp"`.

The controlling macros are `IMAGINARYPLAYER_STRING_VIEW_BOOST` and `IMAGINARYPLAYER_OPTIONAL_BOOST`.
They may be predefined by the user (e.g. via the `CXXFLAGS` envvar when invoking the `./Go` build script).
A zero value means that the Standard Library version is to be used.
A non-zero value means that the Boost version is to be used.

The resulting identifiers are placed in the `lyb` namespace, so our code uses `lyb::optional <...>` instead of `std::optional <...>` etc.

(By default, the Standard Library versions are used. However, the `Go.bat` script -- which is meant primarily for my home computer -- sets these variables to 1 before invoking the `./Go` script.)



== Higher-level conventions (idioms and design patterns)

For classes with virtual functions (classes within hierarchies), the Template design pattern is used extensively.
Specifically, the important sub-case called the Non-Virtual Interface design pattern is used.
It is described in Herb Sutter's "Virtuality" article (2001) (http://www.gotw.ca/publications/mill18.htm).

Shortly, we avoid public virtual functions (just like the Standard Library avoids them) -- except (for technical reasons) for the destructor.
The non-public virtual functions often have a `Do_` prefix in their names.
The public non-virtual (wrapper) functions often invoke one or more non-public virtual functions while adding instrumentation
(testing of pre-conditions, testing of post-conditions, pre-logging, post-logging, decision making etc.).

The Strategy design pattern is also used when appropriately, e.g. for `Worker` objects which are (optionally) configured with `WorkerImpl`-derived objects.



== And what about Named Arguments for Function Calls ?

Languages such as Python allow the caller to specify the name for each argument (instead of relying on the position of the argument in the argument list).

In the "The Design and Evolution of C++" book (1994), Bjarne Stroustrup describes how this can be implemented in C++
(the reason for refusing similar proposals for C++). Please see Section 6.5.1.1 ("Alternatives to Keyword Arguments") on page 156 (in the "Standardization" chapter).

This technique relies on the "setter" member functions returning reference to (non-const) `*this`.
IMO, this exploits a minor loophole in the language: we cannot bind an lvalue-reference-to-non-const to a temporary object (i.e. to a prvalue),
but we can call non-const member functions for such a temporary object.
So we cannot write `v.swap (std::vector <Widget> ())`, but we can write `std::vector <Widget> ().swap (v);`.

In this project, we use a modern implementation of that technique (personal invention, or possibly re-invention -- if someone else has used this before me),
which relies on C++11 `auto` for even greater convenience
(and on C++11 move semantics for efficiency even in the absence of copy elision)
(and on C++17 guaranteed copy elision).

For example, in the `Song_UT.cpp` unittest, we can see this code:

```
const auto song = Song {}.SetArtistName ("Madonna").SetSongName ("Frozen").SetCodecName ("MP3").SetLength (std::chrono::minutes {5} + std::chrono::seconds {29});
```

This is safer and more expressive and (IMO) more convenient than:

```
const Song song ("Madonna", "Frozen", "MP3", std::chrono::minutes {5} + std::chrono::seconds {29});
```

(especially given the fact that the first three arguments have the same type => no compiler warning in case of mismatch).





== Implementation of the Project

We have three threads:

* the Main thread;
* two Worker threads: the Player thread and the Logger thread.

The Logger thread is responsible for logging (`std::cout` output).
